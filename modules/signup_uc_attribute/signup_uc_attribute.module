<?php
// $Id$
/**
 * @file signup_uc_attribute.module
 * Provides integration between signup and ubercart attributes: provides a 
 * signup form pane for the product attributes.
 *
 * This is tied in with uc_attribute because I don't see a way of having the connection
 * to UC in one module and the handling of attributes in another. Both would
 * want to call uc_cart_add_item(); or the uc_attribute glue module would
 * have to alter the product already in the cart and it seems messy. But
 * suggestions welcome!
 *
 * The flows are as follows:
 *  - User signs up for an event: the signup node product is added to their cart
 *    and a record is added to {signup_uc_cart_products} to connect the signup and the cart item.
 *    - signup_uc_attribute_form
 *    - signup_uc_attribute_form_alter
 *    - signup_uc_attribute_signup_data_alter
 *    - signup_uc_attribute_signup_insert
 *  - User removes the signup item from their cart: the signup is cancelled.
 *    - signup_uc_attribute_cart_item, $op = remove
 *  - User checks out: the record from {signup_uc_cart_products} is deleted now 
 *    that the cart is empty; a new record to connect the signup and the order
 *    is created in {signup_uc_order_products}.
 *    - signup_uc_attribute_order
 *    - signup_uc_attribute_cart_item, $op = remove
 *  - User does not check out within a specified delay: the cart is emptied
 *    by uc_cart module and the signup is cancelled,
 *    - signup_uc_attribute_cart_item, $op = remove
 *
 * Data storage:
 *  - We store the relationship between Signup ID (sid) and Ubercart cart item ID
 *    in {signup_uc_cart_products}; once an order is complete the relationship
 *    is then between sid and Ubercart order ID in {signup_uc_order_products}.
 *
 * @todo
 *  - disallow UI cancellation of a UC signup
 *  - disallow changing of UC attributes of an existing signup from the signup form
 *    (or alter the cart item if it's still in the cart)
 *  - deal with signups put into the cart but never bought: cancel them on cron?
 *    consider making this feature as a standalone module so non-paid signups
 *    can use it too somehow. (ie signups that need confirmation?)
 */

/**
 * Implementation of hook_help().
 */
function signup_uc_attribute_help($path, $arg) {
  switch ($path) {
    case 'admin/help#signup_uc_attribute':
      return t('TODO: Create admin help text.');
    // OPTIONAL: Add additional cases for other paths that should display help text.
  }
}

/**
 * Implementation of hook_signup_pane_info().
 *
 * Defines panes available to signup forms.
 * 
 * @param $node
 *  (optional) The node being considered for panes.
 *  We use this to determine whether the node is a product and hence whether our
 *  panes apply.
 *
 * @return
 *  An associative array of data about signup form panes. 
 *  The key is the pane ID. The value is itself an associative array of the
 *  following form:
 *    - label: A label for the admin UI.
 *    - description: A longer description for the admin UI.
 *    - callback: A callback function to generate the form.
 */
function signup_uc_attribute_signup_pane_info($node = NULL) {
  // Only return a pane if the current node is an Ubercart product.
  if (uc_product_is_product($node)) {
    return array(
      'uc_attribute' => array(
        'label' => t('Product attributes'),
        'description' => t("Shows Ubercart attributes for the signup-enable product node, and disables the regular Ubercart 'add to cart' form."),
        'callback' => 'signup_uc_attribute_form',
      ),
    );
  }
}

// -------------------------------- Signup form and associated alterations.

/**
 * Signup form pane callback.
 *
 * Generates the attributes form for this product node from Ubercart.
 * @see signup_uc_attribute_form_alter() which correspondingly suppresses the
 * default Ubercart 'add to cart' form.
 *
 * @param &$signup_form
 *   The form array for the whole signup. You should not alter this, but it
 *   contains useful data depending on circumstances.
 * @param &$form_state
 *   Likewise.
 * @param $node
 *   The fully loaded node object.
 * @param $signup
 *   If this is an existing signup, the fully loaded node object. If this is a 
 *   new signup, this is just NULL.
 * @param $pane_id
 *   The pane ID being invoked. This allows a module to implement multiple panes
 *   with one callback.
 * @param $signup_type
 *   Determines what kind of signup to generate a form for. Possible values:
 *    'auth' -- regular authenticated user signup form
 *    'anon' -- anonymous user signup form (includes required email field).
 *    'admin' -- admin form to signup another user (includes user selector).
 * @return
 *   A form API array for insertion into the signup form. 
 */
function signup_uc_attribute_form(&$signup_form, &$form_state, $node, $signup, $pane_id, $signup_type = 'auth') {
  
  // Add in attributes for this product node.
  $ubercart_form = _uc_attribute_alter_form($node);
  
  // debug
  $cart_id = uc_cart_get_id();
    
  $cart_contents = uc_cart_get_contents($cart_id);
  //dsm($cart_contents);
  
  return $ubercart_form;
}

/**
 * Implementation of hook_form_alter().
 *
 * Remove the 'Add to cart' button and attribute selection when they are shown
 * in the signup pane.
 *
 * We don't use hook_uc_form_alter() because uc_attribute_uc_form_alter() fires 
 * after us and this is easier than fiddling with module weights.
 */
function signup_uc_attribute_form_alter(&$form, $form_state, $form_id) {
  if (substr($form_id, 0, 27) == 'uc_product_add_to_cart_form') {
    $nid = $form['nid']['#value'];
    $node = node_load($nid);
    // Act if the node is signup-enabled and it has the UC attributes pane.
    if ($node->signup && isset($node->signup_form_panes['uc_attribute'])) {
      unset($form['submit']);
      if (isset($form['attributes'])) {
        unset($form['attributes']);
      }
    }
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter(): signup edit form.
 *
 * Replace the cancellation link on the signup edit form with a note about
 * removing the corresponding item from the cart.
 */
function signup_uc_attribute_form_signup_edit_form_alter(&$form, $form_state) {
  $node = node_load($form['#signup']->nid);
  // Only act on signup-enabled nodes that have our pane enabled.
  if (isset($node->signup_form_panes['uc_attribute'])) {
    $result = db_query("SELECT cart_item_id FROM {signup_uc_cart_products} WHERE sid = %d", $form['#signup']->sid);
    if ($cart_item_id = db_result($result)) {
      if (isset($form['elements']['cancel-signup'])) {
        // @todo: this should only be shown if the current user is the user whose signup this is.
        // ie, check for and eliminate the case where an admin is editing the signup.
        $form['elements']['cancel-signup']['#value'] = t('This is a paid signup. You may cancel this by removing the item from your cart.');
      }
    }
    else {
      if ($order_product_id = signup_uc_attribute_get_order_product_id($form['#signup']->sid)) {
        if (isset($form['elements']['cancel-signup'])) {
          // @todo: this should only be shown if the current user is the user whose signup this is.
          // ie, check for and eliminate the case where an admin is editing the signup.
          $form['elements']['cancel-signup']['#value'] = t('You have already paid for this signup. If you wish to cancel it, you should contact the site administrator.');
        }
      }
    }
  }
}

// -------------------------------- Signup workflow.

/**
 * Implementation of hook_signup_data_alter().
 *
 * Intercept signup data before it is saved, and add the signup-enabled product
 * to the cart.
 */
function signup_uc_attribute_signup_data_alter(&$signup, $form_values) {
  // Only act if our pane is enabled on the signup node.
  
  // WTF. Tecnically we don't need this but I was going to put it in just as a safeguard
  // (though can a node ever STOP being a product?) and the cursed thing FAILS. WHY? WTF?
  // dsm('product ((' . $signup->nid . ')) ' . uc_product_is_product($signup->nid));
  if (isset($signup->form_data['uc_attribute'])) {

    dsm($signup);
    dsm($form_values);
    
    /*
    WARNING
    The call to uc_cart_add_item is based entirely on retroengineering what UC
    core does based on shoving in a dsm(func_get_args()) to the top of it.
    This may or may not work in cases I haven't envisioned, and I lay the blame
    entirely at the door of people who do not properly document their APIs!
    */
    $node = node_load($signup->nid);
    $quantity = 1; // TODO: allow more than one with the other patch in the signup queue!
    
    // Get the selected UC attributes from the form.
    $uc_attribute_data = $signup->form_data['uc_attribute'];
    unset($signup->form_data['uc_attribute']);
    
    $data = array(
      'attributes'  => $uc_attribute_data,
      'model'       => FALSE, // no idea why!
      'shippable'   => $node->shippable,
      'signup_in_progress' => TRUE,
    );
    
    // Add the item to the cart.
    // Stuff to figure out:
    // - do we always want this in the current user's cart? what if an admin signs up
    //   another user: should the product appear in that user's cart?
    uc_cart_add_item($node->nid, $quantity, $data,
      NULL, // $cid
      FALSE // $msg: whether to output messages
      //TRUE  // $check_redirect??? @todo figure out if this is useful to us.
    );

    // Total WTF: uc_cart_add_item() returns no data WHATSOEVER about what we 
    // have just done: no cart ID, no item ID, nada.
    // So we have to take a wild stab at it and HOPE LIKE HELL that a site admin
    // is not adding to a user's cart at the same time (assuming that's possible).
    // @todo: if you have a better idea of how to handle this, please suggest!
    
    $cart_id = uc_cart_get_id();
    $cart_contents = uc_cart_get_contents($cart_id, 'rebuild');
    //dsm($cart_contents);
    
    foreach ($cart_contents as $index => $cart_item) {
      $cart_item_ids[] = $cart_item->cart_item_id;
    }
    $latest_cart_item_id = max($cart_item_ids);
    
    // We have no signup sid here. 
    // In order to set a connection to our own data, we put in our own data's ID 
    // here, so we can retrieve it in hook_signup_insert().
    $signup->temporary_data['uc_attribute_latest_cart_item_id'] = $latest_cart_item_id;
  }
}

/**
 * Implementation of hook_signup_insert().
 *
 * Carries on from signup_webform_signup_data_alter(). Saves the relationship
 * between the signup and the cart item which we couldn't do earlier in 
 * signup_webform_signup_data_alter() because at that point there is no signup id.
 */
function signup_uc_attribute_signup_insert($signup) {
  // Retrieve the cart item ID from the signup data.
  $cart_item_id = $signup->temporary_data['uc_attribute_latest_cart_item_id'];
  
  // Retrieve the cart item.
  $item = uc_cart_get_item($cart_item_id);
  
  // Add the Signup ID to the UC cart item so hook_order() has SOME CLUE of
  // who we are and what we're doing.
  // This is messy as both IDs (signup and cart item) are now kicking about
  // in the serialized data of the opposite item: but either way someone's
  // losing a trailer.
  // @see <http://drupal.org/node/744954>.
  $item->data['signup_sid'] = $signup->sid;
  
  // Update the cart item.
  uc_cart_update_item($item);
  
  // Store our own data: we store a relationship between:
  // - signup ID
  // - cart ID
  // Other data such as uid and nid is accessible from both of these.
  db_query("INSERT INTO {signup_uc_cart_products} (sid, cart_item_id) VALUES (%d, %d)", 
    $signup->sid, $cart_item_id);  
}

// -------------------------------- Miscellaneous glue.

/**
 * Implementation of hook_order().
 */
function signup_uc_attribute_order($op, &$arg1, $arg2) {
  if ($op == 'submit') {
    // The order is being submitted. 
    // The cart has not yet been emptied (PHEW! Otherwise I see no way to find out
    // information about our items).
    
    //       db_query("DELETE FROM {signup_uc_cart_products} WHERE cart_item_id = %d", $item->cart_item_id);
    dsm($op);
    dsm($arg1);
    
    $order_products = $arg1->products;
    foreach ($order_products as $product) {
      if (isset($product->data['signup_sid'])) {
        // We have a signup product.
        $signup_sid = $product->data['signup_sid'];
        
        dsm("have sid $signup_sid");
        
        // Store our own data: we store a relationship between:
        // - signup ID
        // - order ID
        // - order product ID
        db_query("INSERT INTO {signup_uc_order_products} (sid, order_id, order_product_id) VALUES (%d, %d, %d)", 
          $signup_sid, $arg1->order_id, $product->order_product_id);

        // We need to clear our entry in {signup_uc_cart_products} as although
        // hook_cart_item() op 'remove' will get called, we do some heavy work 
        // to bypass it.
        // Delete our cart record.
        db_query("DELETE FROM {signup_uc_cart_products} WHERE sid = %d", $signup_sid);
      }
    }
    
    /*
    // Get the cart contents.
    $cart_id = uc_cart_get_id();
      
    $cart_contents = uc_cart_get_contents($cart_id);
    dsm($cart_contents);
    */
    
  }
  
  if ($op == 'delete') {
    // Delete our order record.
    db_query("DELETE FROM {signup_uc_order_products} WHERE order_id = %d", $arg1->order_id);
  }
}


/**
 * Implementation of hook_cart_item().
 *
 * Act when a signup item is removed from the cart:
 * - cancel the signup
 * - remove our record
 */
function signup_uc_attribute_cart_item($op, &$item) {
  switch ($op) {
    case 'remove':
      // Act when a signup item is removed from the cart:
      // - cancel the signup
      // - remove our record
      
      // WTF? We seem to come here with our data still serialized.
      // Might be a bug in this module BUT NO TIME!!!!!!!!!!!!!!!!!!
      if (!is_array($item->data)) {
        $item->data = unserialize($item->data); 
      }
      
      // This is a WTF. We have to query {signup_uc_order_products} just to 
      // determine whether the product is being removed from the cart by the 
      // user (in which case we cancel the signup) or the cart is going through
      // checkout (in which case we do not!).
      // This is because the 'remove' op is called both when the user manually 
      // chooses not to buy a product AND when the cart is emptied for the 
      // order creation.
      // Bit of a WTF, no?
      // @see <http://drupal.org/node/744956> for a patch.
      if ($order_product_id = signup_uc_attribute_get_order_product_id($item->data['signup_sid'])) {
        return;
      }

      // If we are still here, we cancel the signup.
      // Load the product node (it is likely to be cached, eg if we are on the cart page).
      $node = node_load($item->nid);
      if ($node->signup) {
        // Retrieve the signup.
        $query = db_query("SELECT sl.* FROM {signup_log} sl LEFT JOIN {signup_uc_cart_products} sucp ON sl.sid = sucp.sid WHERE sucp.cart_item_id = %d", $item->cart_item_id);
        while ($signup = db_fetch_object($query)) {
          signup_cancel_signup($signup);
        }
      }
      // Delete our cart record.
      db_query("DELETE FROM {signup_uc_cart_products} WHERE cart_item_id = %d", $item->cart_item_id);
      
      break;
  } 
}

/**
 * Implementation of hook_signup_cancel().
 *
 * When a signup is canceled, delete our data.
 THIS HOOK IS NOT NEEDED: we operate from the UC side.
 *
 * @todo: find a way to prevent UI cancellation of signups: 
 *  - if the product is in the cart, remove it from the cart
 *  - if the order is complete, errr.... no idea!
 */
function Xsignup_uc_attribute_signup_cancel($signup, $node) {
}

// -------------------------------- Utility.

/**
 * Helper function check if a signup is fully paid for.
 *
 * @param $sid
 *  The Signup sid.
 *
 * @return
 *  The UC order_product_id, if it exists.
 */
function signup_uc_attribute_get_order_product_id($sid) {
  $result = db_query("SELECT order_product_id FROM {signup_uc_order_products} WHERE sid = %d", $sid);
  if ($order_product_id = db_result($result)) {
    return $order_product_id;
  }
}
